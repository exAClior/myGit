#+TITLE: Learning notes for ai on udacity

* <2018-10-17 Wed>

** using anaconda
   conda install 'package_name'
   conda search 'package_name_approx'

** Creating and using  another encironment
   conda create -n env_name [list of packages] [python= version_number]
   source activate my_env
   source deactivate
   conda env export > environment.yaml : export the current enviroment into a file
   conda env create -f environment.yaml : load environment from a file
   conda env remove -n env_name : remove an environment

** Things about using an environment 
   create two env for python2 and python3 for general use
   pip freeze > requirements.txt : does the same job as conda env export 
   [[https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/][Extra Learning on Conda]]

** Jupyter note book 

*** Literate programming 
    documentation is written as a narrative alongside the code

*** How notebooks work 
    server renders notebook file and then send it via http&websockets to user
    the code part of the notebook is sent to the kernel
    kernel can not only interprete one language but many 
    
* <2018-10-16 Tue>

** Create one environment to each project 
   Use Conda, more specifically, : conda create

** Copy your current dependency for others to follow
   pip freeze > requirement.txt
* <2018-10-15 Mon>

** encapsulation
   Grouping different functions into a class
   This hides the implementation of different functions
** creater function
   __init__(arguments)
** self argument
   If you want to access attributes of a class, you would have to include
   the self as one argument
** 
* <2018-10-13 Sat>

**  Use argparse() to write user-friendly command line interface

** 
* <2018-10-12 Fri>
** Reading and Writing File
*** open("filename",mode of opening) returns a file object
****  this object that we operate them
**** if you forget to close file, you can run out of file handle thus no longer be able to open new files
****  if you open file with "w" mode, you delete everything it contains before
****  if you want to append use "a" mode
*** with .... as ..... 
**** with open('my_path/my_file.txt', 'r') as f:
**** automatically closes f outside the scope
****  but things decleared inside the with scope is not limited to exist before with .... as ends:
*** Use readline() to read line by line in python
*** use strip() to remove '\n'
** Import Local scripts
***  import "url to otherfiel/name of the file"
***  Note, when we import other file, any thing that is ran in that file will be run at the same time when we run our file
***  If you want to access object num in another  file : anotherfile, use : anotherfile.name
***  the same is with functions
***  use import lonenamefile as abrev, to simplify the calling function process
***  if there is executing block of code in a file, put them under the if __name__ = "__main__" block of code
**** or first put them under def  main(): then do if __name__ == "__main__" : main()
****  this ensures that the block of code will only be executed if the file is been called upon, not imported.
****  when being imported, the __name__  = nameoffile
****  if called directly upon, __name__ = "__main__"
**  [[https://docs.python.org/3/library/][Python Standard Library]]
***  random.choice()
****  choose random object from a collection of data
***  random.sample(container name, number)
****  pick randomly a number of objects from a container
** Techniques for Importing Modules
***  import just few functions
****  from module_name import object_name1, name 2, name 3 
      from module_name import object_name as abbrev
**  Third-party libraries
***  import third party libraries after standard library
***  include "requirement.txt" with yoour code so that collaborators know which libraries they need to install
***  include versions is good practise
***  use pip install -r requirement.txt to install these requirements
* <2018-10-08 Mon>
** Accessing Error Messages
***  use "except .... as var_name" to store the error message into a string
***  if you want to catch any exception in general use keyword "Exception"
** Scripting with Raw Input
*** eval(" a string") evaluates the string as a line of python code
** Errors and Exceptions
*** try statement: runs a line of code
***  except statement : if exception is raised, run the following code
***  else statement: in the same indent as except statement, if no exception is raised, run that
***  finally statement: same indent as try, it is excecuted no matter what the previous things do, even if you ask the previous things to close the program
*** [[https://stackoverflow.com/questions/11551996/why-do-we-need-the-finally-clause-in-python][Why do we need finally ]]
***  except (tuples of exception you want this to catch)
***  may even use multiple except for one try to act differently according to different errors
* <2018-10-07 Sun>
** Iterators and Generators
*** Iterables: OBJECTS that gives you one element at a time when operated on it properly
****  eg; list , the return value of enumerate
***  iterator : what is created by generators
**** it represents a stream of data , which is different from list, a collection of data
*** generators :
**** Like functions that return a list, instead uses key word "yield" and return an iterator
**** use generators instead of list because we can generate/access the wanted element one at a time thus puts less stress on memoery [[https://softwareengineering.stackexchange.com/questions/290231/when-should-i-use-a-generator-and-when-a-list-in-python/290235][Why Generator]]
*** sq_list = [x**2 for x in range(10)]  # this produces a list of squares            sq_iterator = (x**2 for x in range(10))  # this produces an iterator of squares
** Lambda function
***  put the following into where you need the lambda function to go,i.e as a parameter of another function
****  lambda "parameters.....": what you need to do with these parameters
****  If you actually need to call this function later, assign name to this lambda function : func_name = lambda parameter : operation
** Scope
*** If a function tries to modify a global variable or something that is defined outside of the func, error occurs
** Functions
*** def func_name(arguments):
*** You may also do this when calling a function func(para1 = 10, para2=5), this is called pass by name
* <2018-10-06 Sat>

** For loops

*** range(start = 0, stop, step =1), if sepcify two variable, the first variable is start
*** string: lower() -> change all character into lower
*** string: replace("c1","c2") replace c1 into c2 in the string called upon
***  if range(start,end) start > end , returns empty list
***  dict().items() return a tuple of key and value in the dictionary
** Break, Continue
*** break breaks out a loop entires
*** continue skips one iteration of a loop
** Zip and Enumerate
***  zip returns ITERATOR of the combined two lists, we need to use list() to convert the return value of zip into an actual list
***  *some_list unzips a list of tuples but you have to use it in conjunction with zip()
***  enumerate() returns both the index and item of an iterable data structure
*** to transpose a matrix do tuple(zip(*data)
** List comprehension
*** capitalized_cities = [city.title() for city in cities]
*** squares = [x**2 if x % 2 == 0 else x + 3 for x in range(9)]
*** passed = [name  for name in scores  if scores[name] >= 65  ]
* <2018-10-05 Fri>
** Lists and Membership Operators
*** If you use index -1 you get the last item, -2 second to last
*** let q3 be a list q3[3:6] slices 
*** python list can contain a mix of different data types
*** use key word "in" "not in" to determine whether a data is in a list or not
*** List is a mutable data strucvture  type but string is not
*** the other important quality is whether a data structure type is ordered or not
*** ordered or not depends on whether we can use the position of the element in a data structure to access them
** List Methods
*** Lists are likely to be pass by reference since one list which are pointed by two different variable names are mutated at the same time when one varies
*** for string, max operator compares the alphabetical order
*** sorted() sorts the data structure
*** string.join(..) joins string elements together connecting them with the string on which join is called upon
** Tuples
***  Like list but are immutable and ordered
** Sets
***  Unordered and unique elements, can create set from lists using set(list_name)
*** pop()
** Dictionary
*** store key and value pair
*** use "in" or ".get()" to check if a key is in the dict
*** dictionary keys must be immutable
*** can setup what if return if .get() fails to grab what you want
** Compund Data Structure
*** Can setup dictionary as value of another dictionary
* <2018-10-04 Thu>
** Integer and Floats
*** Use type(x) to look up the type of a variable
*** use int(x) to cast x into a data type
*** 
** String
*** String in python is immutable
*** + to combine string
*** * to multiply string
*** format() can be used to print designated outputs 
* <2018-10-03 Wed>
** Arithemetic operator 
*** to take power, use "**"
*** ^ does bitwise xor
*** "//" integer division, rounds the answer down 

























 






